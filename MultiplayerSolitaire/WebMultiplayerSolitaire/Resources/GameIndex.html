<!doctype html>
<meta charset="utf-8">
<style>
    #mainTable {
        text-align:left;
        vertical-align:top;
        width:100%;
    }

        #mainTable > tbody > tr > th {
            vertical-align: top;
        }

    #infoParagraph {

    }

    #output {
        overflow: auto;
        float: right;
        border: 1pt;
        border-color: black;
        border-style: solid;
        min-width: 300pt;
        max-width: 50%;
    }

    #output > p {
        overflow-wrap: break-word;
    }

    #output span {
        color: blue;
    }

    #output span.error {
        color: red;
    }

    .card {
        border: 1pt;
        border-style: solid;
        border-color: darkgray;
        width:100pt;
        height:120pt;
        text-align:center;
        vertical-align:central;
    }

    .cardSlot {
        border: 1pt;
        border-style: solid;
        border-color: darkgray;
        width: 102pt;
        height: 122pt;
        text-align: center;
        vertical-align: central;
    }

    .deck {
        border: 1pt;
        border-style: solid;
        border-color: darkgray;
    }

    .otherPlayer {
        border: 1pt;
        border-style: solid;
        border-color: black;
    }


</style>
<h2>Two Players Solitaire</h2>
<table id=mainTable>
    <tr>
        <th>
            <div id=playArea></div>
        </th>
        <th>
            <div id=output></div>
        </th>
    </tr>
</table>

<div id="signature">
    Made by <a href="https://antonmakesgames.itch.io/" target="_blank" rel="noopener noreferrer">AntonMakesGames</a>
</div>

<script src="Card.js"></script>
<script src="CardDisplay.js"></script>
<script src="CardSlot.js"></script>
<script src="Deck.js"></script>
<script src="GameInfo.js"></script>
<script src="Opponent.js"></script>
<script src="Player.js"></script>
<script src="PlayerSlots.js"></script>
<script src="WebSocket.js"></script>

<script>
    const GameStateID = [
        "Initialize",
        "Playing",
        "Transitioning",
        "EndGame",
        "Unkown"];

    const SigilLabel = [
        "Spade",
        "Club",
        "Heart",
        "Diamond"];

    const SigilSymbol = [
        '\u2660',
        '\u2663',
        '\u2661',
        '\u2662'];

    const ValueLabel = [
        "Ace",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
    ];

    var websocket = null;
    var isConnected = false;
    var gameWebSocketUrl = document.URL.replace("http://", "ws://");

    var output = document.querySelector("#output");
    var playArea = document.querySelector("#playArea");

    var player = new Player();
    var playerSlots = new PlayerSlots();
    var gameInfo = new GameInfo();
    var opponent = new Opponent();

    var clientState = "None";
    var localPlayerIndex = -1;
    var availableSlots = [];
    var nextOrderID = 0;

    var pendingOrders = [];
    var messageHandles = [];
    var gameState = null;

    messageHandles["AvailablePlayerSlots"] = handleAvailablePlayerSlots;
    messageHandles["OrderAcknowledgement"] = handleOrderAcknowledgement;
    messageHandles["PlayerViewUpdate"] = handlePlayerViewUpdate;
    messageHandles["SandboxChanges"] = handleSandboxUpdate;

    writeToScreen("WS URI " + gameWebSocketUrl);

    CreateWebSocket();

    function writeToScreen(message) {
        output.insertAdjacentHTML("afterbegin", "<p>" + message + "</p>");
    }

    function handleOrderAcknowledgement(messageData) {
        if (pendingOrders[messageData.OrderID] != null) {
            pendingOrders[messageData.OrderID](messageData);
            pendingOrders[messageData.OrderID] = null;
        }else {
            writeToScreen("No acknowledgment found for order " + messageData.OrderID + ".");

            var pendingOrderKeys = pendingOrders.keys();
            var keyMessage = "PendingOrder keys :";
            for (const key of pendingOrderKeys) {
                keyMessage += " " + key;
            }

            writeToScreen(keyMessage);
        }
    }

    function handleAvailablePlayerSlots(messageData)
    {
        availableSlots = messageData.AvaialablePlayerSlots;

        // are we searching for a player slot ?
        if (localPlayerIndex < 0) {
            clearPlayArea();

            playerSlots.Setup(availableSlots);
            playArea.appendChild(playerSlots.RootNode);
        }
        else {
            // if not, how many are still open ?
            var numberOfAvailableSlots = 0;
            for (var index = 0; index < availableSlots.length; ++index) {
                if (availableSlots[index]) {
                    numberOfAvailableSlots++;
                }
            }

            // we are waiting for the slots to be taken
            if (numberOfAvailableSlots > 0) {
                clearPlayArea();

                var p = document.createElement("p").appendChild(document.createTextNode("Waiting for " + numberOfAvailableSlots + " players."));
                playArea.appendChild(p);
            }
            else {
                // we are ready to play, are we already playing ?
                if (clientState == "None") {
                    if (gameState == null) {
                        clientState = "WaitingForGameState";
                    }
                    else {
                        SetupFromGameState();
                    }
                }
            }
        }
    }

    function handlePlayerViewUpdate(messageData)
    {
        gameState = messageData;

        if (GameStateID[gameState.GameStateID] != null) {
            gameState.GameStateID = GameStateID[gameState.GameStateID];
        }

        if (clientState == "WaitingForGameState") {
            SetupFromGameState();
        }

        writeToScreen("Game state = " + gameState.GameStateID);
    }

    function handleSandboxUpdate(messageData) {
        for (var changeIndex = 0; changeIndex < messageData.GameChanges.length; ++changeIndex) {
            var gameChange = messageData.GameChanges[changeIndex];
            var changeType = gameChange.ChangeType;
            if (changeType == "PlayedCard") {
                if (gameState.CurrentPlayer != gameChange.PlayerIndex) {
                    alert("Desync between local player and playing player.");
                    return;
                }

                var card = new Card(gameChange.IndexOnBoard);
                card.Setup(gameChange.Card);

                if (gameChange.PlayerIndex == localPlayerIndex) {
                    if (!AssertClientState("PlayedCard")) {
                        return;
                    }

                    PlayerhandModeUninteractable();
                    PlayerBoardModeUninteractable();
                    player.Hand.Slots[gameChange.IndexInHand].DetatchCard();
                    player.Board.Slots[gameChange.IndexOnBoard].AttachCard(card);
                }
                else {
                    if (!AssertClientState("OtherPlayerTurn")) {
                        return;
                    }

                    opponent.Board.Slots[gameChange.IndexOnBoard].AttachCard(card);
                }
            }
            else if (changeType == "PickedCard") {
                if (gameChange.PlayerIndex == localPlayerIndex) {
                    var newCard = new Card(gameChange.IndexInHand);
                    newCard.Setup(gameChange.Card);
                    player.Hand.Slots[gameChange.IndexInHand].AttachCard(newCard);
                } 
            }

            else if (changeType == "PlayerCombo") {
                if (gameChange.PlayerIndex == localPlayerIndex) {
                    for (var index = 0; index < 3; ++index) {
                        if ((gameChange.UsedCards & 1 << index) != 0) {
                            player.Board.Slots[index].DetatchCard();
                        }
                    }
                }
                else {
                    for (var index = 0; index < 3; ++index) {
                        if ((gameChange.UsedCards & 1 << index) != 0) {
                            opponent.Board.Slots[index].DetatchCard();
                        }
                    }
                }
            }
            else if (changeType == "PlayerPropertyChanged")
            {
                var target = player;
                if (gameChange.PlayerIndex != localPlayerIndex) {
                    target = opponent;
                }

                if (gameChange.PlayerProperty == "Score") {
                    target.ScoreLabel.textContent = "Score " + gameChange.NewValue;
                }

                if (gameChange.PlayerProperty == "Health") {
                    target.HealthLabel.textContent = "Health " + gameChange.NewValue;
                }

                if (gameChange.PlayerProperty == "Shield") {
                    target.ShieldLabel.textContent = "Shield " + gameChange.NewValue;
                }

                if (gameChange.PlayerProperty == "PairBullets") {
                    target.PairBulletLabel.textContent = "Pair Bullets " + gameChange.NewValue;
                }
            }

            else if (changeType == "GameStateChange") {
                gameState.GameStateID = gameChange.GameStateID;
                if (gameState.GameStateID == "Transitioning") {
                    gameState.CurrentPlayer = gameChange.PlayerIndex;
                    if (gameState.CurrentPlayer == localPlayerIndex) {
                        PlayerHandModeChooseCard();
                        clientState = "SelectHandCard";
                    }
                    else {
                        clientState = "OtherPlayerTurn";
                    }
                }
            }
        }
    }

    function SelectCardInHand(cardIndex) {
        if (!AssertClientState("SelectHandCard")){
            return;
        }

        player.SelectedCardIndex = cardIndex;

        for (var index = 0; index < 3; ++index) {
            var card = player.Hand.Slots[index].Card;
            if (index == cardIndex) {
                card.SetInteractable(UnselectCard, "X");
            }
            else {
                card.SetNotInteractable();
            }
        }

        PlayerBoardModeChooseSlot();

        clientState = "SelectBoardSlot";
    }

    function UnselectCard(cardIndex) {
        if (!AssertClientState("SelectBoardSlot")) {
            return;
        }

        PlayerHandModeChooseCard();
        PlayerBoardModeUninteractable();
        clientState = "SelectHandCard";
    }

    function SelectBoardSlot(slotIndex) {
        if (!AssertClientState("SelectBoardSlot")) {
            return;
        }

        PlayerhandModeUninteractable();
        PlayerBoardModeUninteractable();
        clientState = "PlayedCard";
        RequestPlayCard(player.SelectedCardIndex, slotIndex);
    }

    function PlayerHandModeChooseCard() {
        for (var index = 0; index < 3; ++index) {
            var card = player.Hand.Slots[index].Card;
            card.SetInteractable(SelectCardInHand, "Play");
        }
    }

    function PlayerhandModeUninteractable() {
        for (var index = 0; index < 3; ++index) {
            var card = player.Hand.Slots[index].Card;
            card.SetNotInteractable();
        }
    }

    function PlayerBoardModeChooseSlot() {
        for (var index = 0; index < 3; ++index) {
            var slot = player.Board.Slots[index];
            slot.SetInteractable(SelectBoardSlot, "Play");
        }
    }

    function PlayerBoardModeUninteractable() {
        for (var index = 0; index < 3; ++index) {
            var slot = player.Board.Slots[index];
            slot.SetNotInteractable();
        }
    }

    function SetupFromGameState() {
        if (gameState == null) {
            alert("GameState is null | clientState : " + clientState);
            return;
        }

        if (gameState.GameStateID == "Playing") {
            if (clientState == "None") {
                clearPlayArea();

                // Settuping the board.
                gameInfo.Setup(localPlayerIndex, gameState);
                playArea.appendChild(gameInfo.RootNode);

                opponent.Setup(gameState.OtherPlayer);
                playArea.appendChild(opponent.RootNode);

                player.Setup(gameState);
                playArea.appendChild(player.RootNode);

                if (gameState.CurrentPlayer == localPlayerIndex) {
                    PlayerHandModeChooseCard();
                    clientState = "SelectHandCard";
                }
                else {
                    clientState = "OtherPlayerTurn";
                }
            }
        }
    }

    function RequestPlayerSlots(requestedIndex) {
        if (localPlayerIndex >= 0) {
            return;
        }

        if (!availableSlots[requestedIndex]) {
            return;
        }

        var orderID = nextOrderID++;
        var requestPlayerIndex = '{"OrderType":"SelectPlayerSlot", "PlayerIndex": ' + requestedIndex + ', "OrderID" : ' + orderID + '}';
        pendingOrders[orderID] = function (responseData) {
            if (responseData.FailureFlags == "None") {
                localPlayerIndex = requestedIndex;
            }
        };

        DoSend(requestPlayerIndex);
    }

    function RequestPlayCard(cardIndex, boardIndex) {
        var orderID = nextOrderID++;
        var playOrder = '{"OrderType":"PlayCard", "CardIndex": ' + cardIndex + ', "BoardIndex": ' + boardIndex + ', "OrderID": ' + orderID + '}';
        pendingOrders[orderID] = function (responseData) { };

        DoSend(playOrder);
    }

    function clearChilds(node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    }

    function clearPlayArea() {
        while (playArea.firstChild) {
            playArea.removeChild(playArea.firstChild)
        }
    }

    function createElementWithClass(element, className) {
        var el = document.createElement(element);
        el.className = className;
        return el;
    }

    function AssertClientState(expectedState) {
        if (clientState != expectedState) {
            alert("Unexpected state " + clientState + " expecting " + expectedState);
            return false;
        }

        return true;
    }

</script>